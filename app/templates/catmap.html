{% extends "base.html" %}

{% block title %}Cat Map{% endblock %}

{% block head %}
{{ super() }}
<link rel="stylesheet" href="https://unpkg.com/leaflet@1.9.4/dist/leaflet.css" />
<script src="https://unpkg.com/leaflet@1.9.4/dist/leaflet.js"></script>
<script src="https://unpkg.com/h3-js@4.1.0/dist/h3-js.umd.js"></script>
<script src="{{ url_for('static', filename='js/map-theme.js') }}"></script>
<style>
    #map {
        height: min(60vh, 600px);
        width: 100%;
        border-radius: 0.5rem;
    }
    
    .map-controls {
        position: absolute;
        top: 1rem;
        right: 1rem;
        z-index: 1000;
        background: white;
        padding: 1rem;
        border-radius: 0.5rem;
        box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        width: 300px;
    }
    
    .dark .map-controls {
        background: #1f2937;
        color: white;
    }
    
    .colony-filters {
        display: none;
        margin-top: 1rem;
    }
    
    .colony-filters.active {
        display: block;
    }
    
    .slider-label {
        display: flex;
        justify-content: space-between;
        align-items: center;
        margin-bottom: 0.25rem;
    }
    
    .slider-value {
        font-size: 0.875rem;
        color: #6b7280;
    }
    
    .dark .slider-value {
        color: #9ca3af;
    }
    
    input[type="range"] {
        width: 100%;
        margin: 0.5rem 0;
    }
    
    .view-toggle {
        display: flex;
        gap: 0.5rem;
        margin-bottom: 1rem;
    }
    
    .view-toggle button {
        flex: 1;
        padding: 0.5rem;
        border-radius: 0.375rem;
        font-size: 0.875rem;
        font-weight: 500;
        transition: all 0.2s;
    }
    
    .view-toggle button.active {
        background-color: #2563eb;
        color: white;
    }
    
    .dark .view-toggle button.active {
        background-color: #3b82f6;
    }
    
    .view-toggle button:not(.active) {
        background-color: #f3f4f6;
        color: #374151;
    }
    
    .dark .view-toggle button:not(.active) {
        background-color: #374151;
        color: #d1d5db;
    }
    
    .sightings-list {
        max-height: 400px;
        overflow-y: auto;
    }
    
    .sighting-item {
        padding: 1rem;
        border-bottom: 1px solid #e5e7eb;
    }
    
    .dark .sighting-item {
        border-bottom-color: #374151;
    }
    
    .sighting-item:last-child {
        border-bottom: none;
    }
</style>
{% endblock %}

{% block content %}
<div class="container mx-auto px-4 py-6">
    <!-- Disclaimer Section -->
    <div class="mb-6 p-4 bg-blue-50 dark:bg-blue-900 rounded-lg">
        <p class="text-sm text-gray-600 dark:text-gray-300">
            <strong class="dark:text-white">Test Deployment Notice:</strong> This is a test deployment to evaluate iOS app synchronization with the web interface. 
            Sightings displayed on this map should not be considered reliable and may be edited or removed at any time. 
            The official CatMap with complete colony sightings will launch on July 1, 2025.
        </p>
    </div>

    <div class="relative">
        <div id="map"></div>
        
        <!-- Map Controls -->
        <div class="map-controls">
            <div class="view-toggle">
                <button id="sightingsView" class="active">Sightings</button>
                <button id="coloniesView">Colonies</button>
            </div>
            
            <!-- Colony Filters -->
            <div id="colonyFilters" class="colony-filters">
                <div class="mb-4">
                    <div class="slider-label">
                        <span class="text-sm text-gray-700 dark:text-gray-300">Min. Sightings</span>
                        <span class="slider-value" id="minSightingsValue">3</span>
                    </div>
                    <input type="range" id="minSightings" min="1" max="10" value="3"
                           class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                </div>
                
                <div class="mb-4">
                    <div class="slider-label">
                        <span class="text-sm text-gray-700 dark:text-gray-300">Min. Avg. Cats</span>
                        <span class="slider-value" id="minAvgCatsValue">2.0</span>
                    </div>
                    <input type="range" id="minAvgCats" min="1" max="10" value="2" step="0.5"
                           class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                </div>
                
                <div class="mb-4">
                    <div class="slider-label">
                        <span class="text-sm text-gray-700 dark:text-gray-300">Min. Days Active</span>
                        <span class="slider-value" id="minDaysActiveValue">14</span>
                    </div>
                    <input type="range" id="minDaysActive" min="1" max="90" value="14"
                           class="w-full h-2 bg-gray-200 rounded-lg appearance-none cursor-pointer dark:bg-gray-700">
                </div>
                
                <button id="updateColonies" 
                        class="w-full px-4 py-2 bg-blue-600 text-white rounded-md hover:bg-blue-700 focus:outline-none focus:ring-2 focus:ring-blue-500 focus:ring-offset-2">
                    Update Colonies
                </button>
            </div>
        </div>
    </div>

    <!-- Sightings List -->
    <div class="mt-6 bg-white dark:bg-gray-800 rounded-lg shadow-sm">
        <div class="p-4">
            <div id="connectionStatus" class="text-sm mb-4 text-gray-600 dark:text-gray-400">
                Checking API connection...
            </div>
            <h2 class="text-lg font-semibold text-gray-900 dark:text-white">Recent Sightings</h2>
            <div id="sightingsList" class="mt-4 space-y-4"></div>
        </div>
    </div>
</div>
{% endblock %}

{% block scripts %}
<script>
    let map, markersLayer, colonyLayer, markers;
    
    // Initialize map and layers
    function initMap() {
        map = initializeMap('map');
        markersLayer = L.layerGroup().addTo(map);
        colonyLayer = L.layerGroup();
        markers = new Map();
        
        // Load initial sightings
        loadSightings();
    }
    
    // Color scale for cat density
    function getColor(count) {
        return count > 200 ? '#b91c1c' :  // Very high (>200 cats)
               count > 100 ? '#dc2626' :  // High (100-200 cats)
               count > 50  ? '#ef4444' :  // Moderate-high (50-100 cats)
               count > 25  ? '#f87171' :  // Moderate (25-50 cats)
               count > 10  ? '#fca5a5' :  // Low-moderate (10-25 cats)
                           '#fecaca';     // Low (<10 cats)
    }
    
    // Toggle between sightings and colonies view
    document.addEventListener('DOMContentLoaded', function() {
        initMap();
        
        document.getElementById('sightingsView').addEventListener('click', function() {
            this.classList.add('active');
            document.getElementById('coloniesView').classList.remove('active');
            document.getElementById('colonyFilters').classList.remove('active');
            map.removeLayer(colonyLayer);
            map.addLayer(markersLayer);
        });
        
        document.getElementById('coloniesView').addEventListener('click', function() {
            this.classList.add('active');
            document.getElementById('sightingsView').classList.remove('active');
            document.getElementById('colonyFilters').classList.add('active');
            map.removeLayer(markersLayer);
            map.addLayer(colonyLayer);
            updateColonies();
        });
        
        // Update UI when sliders change
        document.getElementById('minSightings').addEventListener('input', function(e) {
            document.getElementById('minSightingsValue').textContent = e.target.value;
        });
        
        document.getElementById('minAvgCats').addEventListener('input', function(e) {
            document.getElementById('minAvgCatsValue').textContent = e.target.value;
        });
        
        document.getElementById('minDaysActive').addEventListener('input', function(e) {
            document.getElementById('minDaysActiveValue').textContent = e.target.value;
        });
        
        document.getElementById('updateColonies').addEventListener('click', updateColonies);
        
        // Update colony filters
        document.getElementById('minSightings').addEventListener('input', function() {
            document.getElementById('minSightingsValue').textContent = this.value;
        });
        
        document.getElementById('minAvgCats').addEventListener('input', function() {
            document.getElementById('minAvgCatsValue').textContent = this.value;
        });
        
        document.getElementById('minDaysActive').addEventListener('input', function() {
            document.getElementById('minDaysActiveValue').textContent = this.value;
        });
    });
    
    // Fetch and display colonies
    async function updateColonies() {
        const minSightings = document.getElementById('minSightings').value;
        const minAvgCats = document.getElementById('minAvgCats').value;
        const minDaysActive = document.getElementById('minDaysActive').value;
        
        try {
            const response = await fetch(`/api/colonies?min_sightings=${minSightings}&min_avg_cats=${minAvgCats}&min_days_active=${minDaysActive}`);
            const colonies = await response.json();
            
            if (colonyLayer) {
                map.removeLayer(colonyLayer);
            }
            colonyLayer = L.layerGroup();
            
            // Group colonies by proximity
            const hexGroups = new Map(); // Map to store colonies by hex index
            
            // First, create hexagons for each colony
            colonies.forEach(colony => {
                if (!colony.latitude || !colony.longitude) {
                    console.warn('Colony missing coordinates:', colony);
                    return;
                }
                
                const h3Index = h3.latLngToCell(parseFloat(colony.latitude), parseFloat(colony.longitude), 9);
                
                // Store colony data with its hex
                if (!hexGroups.has(h3Index)) {
                    hexGroups.set(h3Index, {
                        colonies: [],
                        totalCats: 0,
                        avgBreedingRate: 0,
                        avgSurvivalRate: 0,
                        avgCaretakerSupport: 0
                    });
                }
                
                const group = hexGroups.get(h3Index);
                group.colonies.push(colony);
                group.totalCats += (colony.current_size || colony.currentSize || 0);
                group.avgBreedingRate += colony.breeding_rate || 0;
                group.avgSurvivalRate += colony.adult_survival_rate || 0;
                group.avgCaretakerSupport += colony.caretaker_support || 0;
            });
            
            // Calculate averages for each hex
            hexGroups.forEach((group, h3Index) => {
                const count = group.colonies.length;
                group.avgBreedingRate /= count;
                group.avgSurvivalRate /= count;
                group.avgCaretakerSupport /= count;
            });
            
            // Try to compact adjacent hexes
            const hexIndexes = Array.from(hexGroups.keys());
            const compactedSet = h3.compactCells(hexIndexes);
            
            // Create polygons for each compacted hex
            compactedSet.forEach(h3Index => {
                // Get all original hexes that were compacted into this one
                const uncompacted = h3.uncompactCells([h3Index], 9);
                
                // Aggregate data from all contained colonies
                const containedGroups = uncompacted
                    .filter(hex => hexGroups.has(hex))
                    .map(hex => hexGroups.get(hex));
                
                if (containedGroups.length === 0) return;
                
                const totalCats = containedGroups.reduce((sum, g) => sum + g.totalCats, 0);
                const avgBreedingRate = containedGroups.reduce((sum, g) => sum + g.avgBreedingRate, 0) / containedGroups.length;
                const avgSurvivalRate = containedGroups.reduce((sum, g) => sum + g.avgSurvivalRate, 0) / containedGroups.length;
                const avgCaretakerSupport = containedGroups.reduce((sum, g) => sum + g.avgCaretakerSupport, 0) / containedGroups.length;
                
                // Get the boundary of the compacted hex
                const boundary = h3.cellToBoundary(h3Index);
                const polygonCoords = boundary.map(coord => [coord[0], coord[1]]);
                
                const polygon = L.polygon(polygonCoords, {
                    color: getColor(totalCats),
                    weight: 1,
                    opacity: 0.8,
                    fillOpacity: 0.35
                });
                
                // Add popup with aggregated colony info
                const popupContent = `
                    <div class="text-sm">
                        <p><strong>Total Cats:</strong> ${totalCats}</p>
                        <p><strong>Colonies:</strong> ${containedGroups.reduce((sum, g) => sum + g.colonies.length, 0)}</p>
                        <p><strong>Avg. Breeding Rate:</strong> ${(avgBreedingRate * 100).toFixed(1)}%</p>
                        <p><strong>Avg. Survival Rate:</strong> ${(avgSurvivalRate * 100).toFixed(1)}%</p>
                        <p><strong>Avg. Caretaker Support:</strong> ${(avgCaretakerSupport * 100).toFixed(1)}%</p>
                    </div>
                `;
                polygon.bindPopup(popupContent);
                
                colonyLayer.addLayer(polygon);
            });
            
            colonyLayer.addTo(map);
            
        } catch (error) {
            console.error('Error fetching colonies:', error);
        }
    }
    
    // Add marker to map helper
    function addMarkerToMap(sighting) {
        if (!sighting || !sighting.coordinate || !sighting.coordinate.latitude || !sighting.coordinate.longitude) {
            console.warn('Invalid sighting:', sighting);
            return;
        }
        
        const marker = L.marker([
            parseFloat(sighting.coordinate.latitude), 
            parseFloat(sighting.coordinate.longitude)
        ]);
        
        marker.bindPopup(createPopupContent(sighting));
        markersLayer.addLayer(marker);
        markers.set(sighting.id, marker);
    }
    
    // Create popup content helper
    function createPopupContent(sighting) {
        return `
            <div class="text-sm">
                <p class="font-semibold">${formatDate(sighting.timestamp)}</p>
                <p>Number of cats: ${sighting.best_count}</p>
                <p>Location type: ${sighting.location_type || 'Not specified'}</p>
                ${sighting.notes ? `<p class="mt-2">Notes: ${sighting.notes}</p>` : ''}
                ${sighting.is_feeding ? '<p class="text-blue-600 dark:text-blue-400">Feeding location</p>' : ''}
            </div>
        `;
    }
    
    // Format date helper
    function formatDate(timestamp) {
        if (!timestamp) return 'Unknown date';
        return new Date(timestamp).toLocaleDateString('en-US', {
            year: 'numeric',
            month: 'short',
            day: 'numeric',
            hour: '2-digit',
            minute: '2-digit'
        });
    }
    
    // Update sightings list helper
    function updateSightingsList(sighting) {
        const sightingsList = document.getElementById('sightingsList');
        if (!sightingsList) return;
        
        const sightingElement = document.createElement('div');
        sightingElement.className = 'sighting-item cursor-pointer hover:bg-gray-50 dark:hover:bg-gray-700';
        sightingElement.innerHTML = `
            <div class="flex justify-between items-start">
                <div>
                    <p class="font-semibold text-gray-900 dark:text-white">${formatDate(sighting.timestamp)}</p>
                    <p class="text-gray-600 dark:text-gray-400">Number of cats: ${sighting.best_count}</p>
                    <p class="text-gray-500 dark:text-gray-500">Location type: ${sighting.location_type || 'Not specified'}</p>
                    ${sighting.is_feeding ? '<p class="text-blue-600 dark:text-blue-400">Feeding location</p>' : ''}
                </div>
            </div>
        `;
        
        sightingElement.addEventListener('click', () => {
            const marker = markers.get(sighting.id);
            if (marker) {
                map.setView(marker.getLatLng(), 16);
                marker.openPopup();
            }
        });
        
        sightingsList.appendChild(sightingElement);
    }
    
    // Load sightings helper
    async function loadSightings() {
        try {
            const response = await fetch('/api/sightings');
            const sightings = await response.json();
            console.log('Received sightings:', sightings);
            
            const statusDiv = document.getElementById('connectionStatus');
            if (statusDiv) {
                statusDiv.textContent = 'Connected to API';
                statusDiv.className = 'text-sm mb-4 text-green-600 dark:text-green-400';
            }
            
            // Clear existing markers and list
            markersLayer.clearLayers();
            markers.clear();
            const sightingsList = document.getElementById('sightingsList');
            if (sightingsList) {
                sightingsList.innerHTML = '';
            }
            
            // Add new markers and list items
            sightings.forEach(sighting => {
                addMarkerToMap(sighting);
                updateSightingsList(sighting);
            });
            
            // Ensure markers layer is added to map
            if (!map.hasLayer(markersLayer)) {
                map.addLayer(markersLayer);
            }
            
        } catch (error) {
            console.error('Error loading sightings:', error);
            const statusDiv = document.getElementById('connectionStatus');
            if (statusDiv) {
                statusDiv.textContent = 'Error connecting to API';
                statusDiv.className = 'text-sm mb-4 text-red-600 dark:text-red-400';
            }
        }
    }
</script>
{% endblock %}
